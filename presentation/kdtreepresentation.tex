\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{epstopdf}
\usepackage{textpos}
\usepackage{textcomp}
\usepackage{verbatim}
\usepackage{varwidth}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{graphicx}
%\usepackage{lipsum}
%\usepackage{dblfloatfix}
%\usepackage{multicol}
%\usepackage[ruled]{algorithm2e}

\usefonttheme[onlymath]{serif}
%\setlength{\columnsep}{5cm}

% table of contents font size
\setbeamerfont{section in toc}{size=\footnotesize}
\setbeamerfont{subsection in toc}{size=\scriptsize}
\setbeamerfont{subsubsection in toc}{size=\scriptsize}

\setbeamertemplate{caption}[numbered]

% standard, good-looking theme
\usetheme{Madrid}

% this should put the outline on the header of each page
% can't make it look right, though
% \usetheme{Darmstadt}



\title[Capstone]{Parallel Orthogonal Recursive Bisection}

\author{Team Metropolis:\\
	James Farzi, JJ Lay, Graham West}
\date{April 10, 2019}



%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%
%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%
%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%

\begin{document}

% get title page 
\frame{\titlepage}

\begin{frame}	
	\frametitle{Outline}
	\tableofcontents
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Introduction}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Introduction
		\end{center}
	\end{Huge}
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Implementation}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Implementation
		\end{center}
	\end{Huge}
\end{frame}


\subsection{\texttt{main}}

\begin{frame}
	\frametitle{Building the tree}
	
	Our \texttt{main} was quite simple due to our organization of the project into many levels of functions
	
	\vspace{10pt}
	
	We also were able to use much of the basic initialization and data importing functions from the previous project
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
%		\footnotesize
		\begin{algorithmic}[1]
			\STATE Initialize MPI
			\STATE Set number of files, lines per file to read
			\STATE import the $data$
%			\STATE MPI\_Barrier
			\STATE Initialize $tree$
			\STATE \texttt{buildTree}($data$, $tree$, $comm$, $\cdots$)
%			\STATE MPI\_Barrier
			\STATE Search the tree with \texttt{search501}( $tree$, $\cdots$)
%			\STATE MPI\_Barrier
			\STATE Finalize MPI
		\end{algorithmic}
	\caption{\texttt{buildTree}($\cdots$)}
	\end{algorithm}
		
\end{frame}


\subsection{KD tree}

%%%%%%%
%%%%%%%
% JJ's stuff about the Tree struct and whatnot
%%%%%%%
%%%%%%%




\subsubsection{Building the tree}

\begin{frame}
	\frametitle{Building the tree}
	
	To build the tree, we use several functions which perform different aspects/sections of the task
	
	\vspace{10pt}
	
	\begin{block}{Functions:}
		\begin{itemize}
			\item \texttt{buildTree}
			\item \texttt{buildTree\_serial}
			\item \texttt{buildTree\_parallel}
			\item \texttt{getSortDim}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Building the tree}
	
	\texttt{buildTree} checks the number of compute nodes in the current communicator and determines whether to call the parallel or serial versions of the code
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
		\begin{algorithmic}[1]
			\STATE $q$ = Size of current communicator
			\IF{ $q > 1$}
				\STATE \texttt{buildTree\_parallel}($\cdots$)
			\ELSE
				\STATE \texttt{buildTree\_serial}($\cdots$)
			\ENDIF
		\end{algorithmic}
	\caption{\texttt{buildTree}($\cdots$)}
	\end{algorithm}
		
\end{frame}

\begin{frame}
	\frametitle{Building the tree}
	
	\texttt{buildTree\_serial} performs ORB using a single compute node
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
		\footnotesize
		\begin{algorithmic}[1]
			\IF{ $tree.n >1$}
				\STATE Calculate $x,y,z$ mins, maxs, ranges, and partition center
				\STATE Sort $data$ over $sortDim = \textrm{argmax}( x,y,z \textrm{ ranges})$
				\STATE Split $data$: $dataL, dataR$
				\IF{ $|dataL| > 0$ }
					\STATE Create $tree.L$
					\STATE \texttt{buildTree\_serial}( $dataL$, $tree.L, \cdots$ )
				\ENDIF
				\IF{ $|dataR| > 0$ }
					\STATE Create $tree.R$
					\STATE \texttt{buildTree\_serial}( $dataR$, $tree.R, \cdots$ )
				\ENDIF
			\ELSE
				\STATE Store $data$ (a single point)
			\ENDIF
		\end{algorithmic}
	\caption{\texttt{buildTree\_serial}($data$, $tree, \cdots$)}
	\end{algorithm}
		
\end{frame}

\begin{frame}
	\frametitle{Building the tree}
	
	\texttt{buildTree\_parallel} performs ORB using a multiple compute nodes
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
		\footnotesize
		\begin{algorithmic}[1]
			\STATE Call \texttt{getSortDim}($\cdots$): calculates $x,y,z$ mins, maxs, ranges, partition center, and returns $sortDim$
			\STATE Sort $data$ over $sortDim$ using \texttt{parallelSort}($data$, $sortDim$, $comm$, $\cdots$ )
			\IF{ $myRank < numNodes/2$ }
				\STATE Create $tree.L$, $commL$
				\STATE \texttt{buildTree\_parallel}( $data$, $tree.L$, $comm, \cdots$ )
			\ELSE
				\STATE Create $tree.R$, $commR$
				\STATE \texttt{buildTree\_parallel}( $data$, $tree.R$, $comm, \cdots$ )
			\ENDIF
		\end{algorithmic}
		\caption{\texttt{buildTree\_parallel}($data$, $tree$, $comm, \cdots$)}
	\end{algorithm}
	
	\vspace{10pt}
	
	It is assumed that $tree.n > 1$ will never occur in \texttt{build/tree\_parallel} since we usually deal with large amounts of data
		
\end{frame}

\begin{frame}
	\frametitle{Building the tree}
	
	\texttt{getSortDim} finds the longest axis and stores several key tree fields
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
%		\footnotesize
		\begin{algorithmic}[1]
			\STATE Each process gets it local $x,y,z$ min and max
			\STATE Rank 0 receives these, determines the global $x,y,z$ min and max, determines the sortDim, and Bcast's all of these values back to the other nodes
			\STATE The global mins/maxs, partition center, and partition radius are stored in $tree$
			\STATE return $sortDim$
		\end{algorithmic}
		\caption{\texttt{getSortDim}($data$, $tree$, $comm, \cdots$)}
	\end{algorithm}
		
\end{frame}


\subsubsection{Searching the tree}

\begin{frame}
	\frametitle{Searching the tree}
	
	\texttt{searchTree\_serial} returns the number of points within a given radius about a given point
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
		\footnotesize
		\begin{algorithmic}[1]
			\STATE $found = 0$
			\STATE $d = \sqrt{ \sum_{i=1}^{3} (point[i] - tree.c[i])^2}$
			\IF{ $d \le rad + tree.rad$ }
				\IF{ $tree.L = NULL$ \&\& $tree.R = NULL$ }
					\STATE return 1
				\ELSE
					\IF{ $tree.L$ != $NULL$ }
						\STATE $found$ += \texttt{searchTree\_serial}($tree.L$, $rad$, $point$)
					\ENDIF
					\IF{ $tree.R$ != $NULL$ }
						\STATE $found$ += \texttt{searchTree\_serial}($tree.R$, $rad$, $point$)
					\ENDIF
				\ENDIF
			\ENDIF
		\end{algorithmic}
		\caption{\texttt{searchTree\_serial}($tree$, $rad$, $point$)}
	\end{algorithm}
		
\end{frame}


\begin{frame}
	\frametitle{Searching the tree}
	
	\texttt{search501} reads the 501-st data file and loops through the points contained within (as well as the three given radii), calling \texttt{searchTree\_serial} for each
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
%		\footnotesize
		\begin{algorithmic}[1]
			\STATE 
		\end{algorithmic}
		\caption{\texttt{search501}($tree$, $path$, $\cdots$)}
	\end{algorithm}
		
\end{frame}


\subsection{Parallel sorting}


\subsubsection{Changes}

\begin{frame}
	\frametitle{Parallel sorting}
	
	We had to make several significant alterations to our \texttt{parallelSort} program in order to integrate it into our KD tree project
	
	\vspace{10pt}
	
	\begin{block}{Changes:}
		\begin{itemize}
			\item Make rank 0 do work
			\item Conversion to function
			\item better \texttt{adaptBins}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Parallel sorting}
	
	\begin{block}{Making rank 0 do work:}
		\begin{itemize}
			\item Initially, rank 0 was just a master node which coordinated the other worker nodes
			\item this technique is very inefficient for parallel ORB since it requires us to switch to serial mode sooner
			\item The solution involved 1) cleverly altering a large number of if statements in the code and 2) changing how certain types of sends/recvs were handled
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Building the tree}
	
	Here is how \texttt{parallelSort} is structured now that it is a function
	
	\vspace{10pt}
	
	\begin{algorithm}[H]
%		\footnotesize
		\begin{algorithmic}[1]
			\STATE 
		\end{algorithmic}
		\caption{\texttt{parallelSort}($data$, $rows$, $myRank$, $sortDim$, $comm, \cdots$)}
	\end{algorithm}
		
\end{frame}


rank 0
multiple communicators

\subsubsection{\texttt{adaptBins}}
old
new
alternating





%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Validation}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Validation
		\end{center}
	\end{Huge}
\end{frame}

\subsection{MATLAB visualitations}

\begin{frame}	
	\frametitle{Validation}
	
	MATLAB Demos:
	
	\begin{itemize}
		\item 2D
		\item 3D
	\end{itemize}
	
\end{frame}


\subsection{Other tests}
tiny/huge radii
multiple nodes



%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Results}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Results
		\end{center}
	\end{Huge}
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Conclusions}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Conclusions
		\end{center}
	\end{Huge}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%% Leftover for reference and copying code %%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%


\begin{comment}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
\begin{frame}	
	\begin{Huge}
		\begin{center}
			The Algorithm
		\end{center}
	\end{Huge}
\end{frame}

\begin{frame}	
	\frametitle{The Algorithm}
	
	\begin{block}{Initial Phase}
		\begin{itemize}
			\item Initialize MPI
			\item Read list of available data files
			\item Distribute available data files to workers
		\end{itemize}
	\end{block}
	
	\begin{block}{Work Phase}
		\begin{itemize}
			\item Import data from files
			\item Perform initial sort
			\item Find uniform bins
			\item Exchange data
			\item Perform final sort
		\end{itemize}
	\end{block}
\end{frame}

\subsection{Distributing/Importing Files}

\begin{frame}	
	\frametitle{Distributing/Importing Files}
	
	\begin{block}{distributeFiles}
		\begin{itemize}
			\item Rank 0 reads files matching \texttt{datafile000000.txt}
			\item Files are distributed round robin to workers
		\end{itemize}
	\end{block}
	
	\begin{block}{importFiles}
		\begin{itemize}
			\item Allocate 1D array of length: \\ \texttt{NumFiles} $\times$ \texttt{MaxLinesPerFile} $\times$ 4 columns
			\item Each worker reads ASCII files and appends data to array
		\end{itemize}
	\end{block}
\end{frame}

\subsection{Sorting}

\begin{frame}    
    \frametitle{Sorting}
    
    We implemented Linked List Insertion Sort and Bubble Sort
    
    \begin{block}{Linked List Insertion Sort}
        \begin{itemize}
            \item Best Case N, Worst Case $N^2$
            \item Selects items one at a time and inserts them in the appropriate place along a linked list
            \item Then replaces the original array with the elements from the linked list
        \end{itemize}
    \end{block}
    
    \begin{block}{Bubble Sort}
        \begin{itemize}
            \item Use: time testing for efficiency
            \item Not to be used during normal operations
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Binning}

\begin{frame}	
	\frametitle{Binning}
	
	\begin{block}{Binary search}
		\begin{itemize}
			\item Since the data is sorted, we can use a binary search to find where the bin edges lie in index space
			\item We can then subtract successive edges' indices to find the number of elements in that bin
		\end{itemize}
	\end{block}
	
	\begin{block}{Initial bin edges}
		\begin{itemize}
			\item As a first approximation, we assume that the bin edges are equally-spaced
			\item We then improve this over time
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{block}{Adapting the bins}
		for interior bin edges (endpoint bins stay constant):
		\begin{equation}
			\begin{split}
				\Delta C & = 2.0 ( c_i^n - c_{i-1}^n ) / ( c_i^n + c_{i-1}^n ) \\
				\Delta B & = b_{i+1}^n - b_i^n \\
				b_i^{n+1} & = b_i^n + \alpha \Delta C \Delta B
			\end{split}
		\end{equation}
		where $0 < \alpha < 0.5$ and $b_i^n < b_{i+1}^n$ for all $n$
	\end{block}
	
	\begin{block}{Uniformity metric}
		\begin{equation}
			U^n = \textrm{max}( \dfrac{c_{\textrm{max}} - c_{\textrm{avg}}}{c_{\textrm{avg}}}, \dfrac{c_{\textrm{avg}} - c_{\textrm{min}}}{c_{\textrm{avg}}} )
		\end{equation}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.25]{AdaptiveBinning_5Nodes_1000Lines_0475alpha}
		\vspace{-10pt}
		\caption{5 nodes, 1000 data points, $\alpha = 0.475$}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.25]{AdaptiveBinning_10Nodes_1000Lines_0475alpha}
		\vspace{-10pt}
		\caption{10 nodes, 1000 data points, $\alpha = 0.475$}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.25]{AdaptiveBinning_10Nodes_1000Lines_0250alpha}
		\vspace{-10pt}
		\caption{10 nodes, 1000 data points, $\alpha = 0.25$}
	\end{figure}
\end{frame}

\subsection{Exchanging data}

\begin{frame}    
    \frametitle{Exchanging data: using swapArrayParts then cleanUp}
    
    \begin{block}{swapArrayParts}
        \begin{itemize}
            \item Takes a specified amount of data from one node and appends it to the end of the existing data for the receiving array
            \item Inside the function: first transmits the length of data to be received then transfers the data
            \item No data is to be deleted at this time
            \item Allows for flexibility in implementation algorithm
        \end{itemize}
    \end{block}
    
    \begin{block}{cleanUp}
        \begin{itemize}
            \item To be used after all nodes have performed a swapArrayParts to all other nodes
            \item Will go back through each nodes array removing data that had been transferred by swapArrayParts and resizing the array for each node
        \end{itemize}
    \end{block}
\end{frame}

%%%%%%%%%%%%
%%% new section %%%
%%%%%%%%%%%%
\section{Testing}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Testing
		\end{center}
	\end{Huge}
\end{frame}

%\subsection{Results}

\begin{frame}	
	\frametitle{distributeFiles}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.30]{distributeFiles.png}
		\vspace{-10pt}
		\caption{Time to read directory and distribute files to workers}
	\end{figure}
	
\end{frame}

\begin{frame}	
	\frametitle{importFiles}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.30]{importFiles.png}
		\vspace{-10pt}
		\caption{Time to import 1000 rows from each file}
	\end{figure}
	
\end{frame}

\begin{frame}	
	\frametitle{initialSort}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.30]{initialSort.png}
		\vspace{-10pt}
		\caption{Time to sort 501000 rows}
	\end{figure}
	
\end{frame}


%%%%%%%%%%%%
%%
%% Conclusions
%%
%%%%%%%%%%%%

\section{Conclusions}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Conclusions
		\end{center}
	\end{Huge}
\end{frame}

\subsection{Challenges}

\begin{frame}	
	\frametitle{Challenges}
	
	\begin{block}{Integration}
		\begin{itemize}
			\item Identifying structure of parameters and return values
			\item Needed better planning of data types up front
		\end{itemize}
	\end{block}
	
	\begin{block}{Git}
		\begin{itemize}
			\item Resolving merge conflicts
			\item Basic Git workflow
		\end{itemize}
	\end{block}

	\begin{block}{Coding}
		\begin{itemize}
			\item Forgot to remove debug controls while collecting performance data
		\end{itemize}
	\end{block}

	\begin{block}{Testing}
		\begin{itemize}
			\item Long runtimes when testing with full dataset
			\item Failures during long runs
		\end{itemize}
	\end{block}

\end{frame}

\subsection{Future Work}

\begin{frame}	
	\frametitle{Future Work}
	
	\begin{block}{Reading the data}
		\begin{itemize}
			\item Read binary datainstead of ASCII for speedup
		\end{itemize}
	\end{block}
	
	\begin{block}{Data types}
		\begin{itemize}
			\item For simplicity, use vectors/structs instead of arrays
		\end{itemize}
	\end{block}
	
	\begin{block}{Finish data swap}
		\begin{itemize}
			\item Resolve scaling issues (overflowing buffer)
		\end{itemize}
	\end{block}
	
	\begin{block}{Testing}
		\begin{itemize}
			\item Easier collection of performance data
			\item Use loops in qsub files to automate multiple runs
		\end{itemize}
	\end{block}
	
\end{frame}

\end{comment}

 
\end{document}












