\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{epstopdf}
\usepackage{textpos}
\usepackage{textcomp}
\usepackage{verbatim}
\usepackage{varwidth}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{graphicx}
%\usepackage{lipsum}
%\usepackage{dblfloatfix}
%\usepackage{multicol}
%\usepackage[ruled]{algorithm2e}

\usefonttheme[onlymath]{serif}
%\setlength{\columnsep}{5cm}

\setbeamertemplate{caption}[numbered]

% standard, good-looking theme
\usetheme{Madrid}

% this should put the outline on the header of each page
% can't make it look right, though
% \usetheme{Darmstadt}

\title[Capstone]{Parallel Orthogonal Recursive Bisection}

\author{Team Metropolis:\\
James Farzi, JJ Lay, Graham West}
%\date{COMS Seminar}%, August 2016}
\date{April 10, 2019}

%\institute
%{
%	GTA, Computational Science\\
%	Middle Tennessee State University\\
%	Research Advisor: John Wallin\\
%}

%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%
%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%
%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%

\begin{document}

% get title page 
\frame{\titlepage}

\begin{frame}	
	\frametitle{Outline}
	\tableofcontents	
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Introduction}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Introduction
		\end{center}
	\end{Huge}
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Implementation}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Implementation
		\end{center}
	\end{Huge}
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Validation}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Validation
		\end{center}
	\end{Huge}
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Results}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Results
		\end{center}
	\end{Huge}
\end{frame}


%%%%%%%%%%%%%
%%% NEW SECTION %%%
%%%%%%%%%%%%%
\section{Conclusions}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Conclusions
		\end{center}
	\end{Huge}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%% Leftover for reference and copying code %%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%


\begin{comment}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
\begin{frame}	
	\begin{Huge}
		\begin{center}
			The Algorithm
		\end{center}
	\end{Huge}
\end{frame}

\begin{frame}	
	\frametitle{The Algorithm}
	
	\begin{block}{Initial Phase}
		\begin{itemize}
			\item Initialize MPI
			\item Read list of available data files
			\item Distribute available data files to workers
		\end{itemize}
	\end{block}
	
	\begin{block}{Work Phase}
		\begin{itemize}
			\item Import data from files
			\item Perform initial sort
			\item Find uniform bins
			\item Exchange data
			\item Perform final sort
		\end{itemize}
	\end{block}
\end{frame}

\subsection{Distributing/Importing Files}

\begin{frame}	
	\frametitle{Distributing/Importing Files}
	
	\begin{block}{distributeFiles}
		\begin{itemize}
			\item Rank 0 reads files matching \texttt{datafile000000.txt}
			\item Files are distributed round robin to workers
		\end{itemize}
	\end{block}
	
	\begin{block}{importFiles}
		\begin{itemize}
			\item Allocate 1D array of length: \\ \texttt{NumFiles} $\times$ \texttt{MaxLinesPerFile} $\times$ 4 columns
			\item Each worker reads ASCII files and appends data to array
		\end{itemize}
	\end{block}
\end{frame}

\subsection{Sorting}

\begin{frame}    
    \frametitle{Sorting}
    
    We implemented Linked List Insertion Sort and Bubble Sort
    
    \begin{block}{Linked List Insertion Sort}
        \begin{itemize}
            \item Best Case N, Worst Case $N^2$
            \item Selects items one at a time and inserts them in the appropriate place along a linked list
            \item Then replaces the original array with the elements from the linked list
        \end{itemize}
    \end{block}
    
    \begin{block}{Bubble Sort}
        \begin{itemize}
            \item Use: time testing for efficiency
            \item Not to be used during normal operations
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Binning}

\begin{frame}	
	\frametitle{Binning}
	
	\begin{block}{Binary search}
		\begin{itemize}
			\item Since the data is sorted, we can use a binary search to find where the bin edges lie in index space
			\item We can then subtract successive edges' indices to find the number of elements in that bin
		\end{itemize}
	\end{block}
	
	\begin{block}{Initial bin edges}
		\begin{itemize}
			\item As a first approximation, we assume that the bin edges are equally-spaced
			\item We then improve this over time
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{block}{Adapting the bins}
		for interior bin edges (endpoint bins stay constant):
		\begin{equation}
			\begin{split}
				\Delta C & = 2.0 ( c_i^n - c_{i-1}^n ) / ( c_i^n + c_{i-1}^n ) \\
				\Delta B & = b_{i+1}^n - b_i^n \\
				b_i^{n+1} & = b_i^n + \alpha \Delta C \Delta B
			\end{split}
		\end{equation}
		where $0 < \alpha < 0.5$ and $b_i^n < b_{i+1}^n$ for all $n$
	\end{block}
	
	\begin{block}{Uniformity metric}
		\begin{equation}
			U^n = \textrm{max}( \dfrac{c_{\textrm{max}} - c_{\textrm{avg}}}{c_{\textrm{avg}}}, \dfrac{c_{\textrm{avg}} - c_{\textrm{min}}}{c_{\textrm{avg}}} )
		\end{equation}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.25]{AdaptiveBinning_5Nodes_1000Lines_0475alpha}
		\vspace{-10pt}
		\caption{5 nodes, 1000 data points, $\alpha = 0.475$}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.25]{AdaptiveBinning_10Nodes_1000Lines_0475alpha}
		\vspace{-10pt}
		\caption{10 nodes, 1000 data points, $\alpha = 0.475$}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{Binning}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.25]{AdaptiveBinning_10Nodes_1000Lines_0250alpha}
		\vspace{-10pt}
		\caption{10 nodes, 1000 data points, $\alpha = 0.25$}
	\end{figure}
\end{frame}

\subsection{Exchanging data}

\begin{frame}    
    \frametitle{Exchanging data: using swapArrayParts then cleanUp}
    
    \begin{block}{swapArrayParts}
        \begin{itemize}
            \item Takes a specified amount of data from one node and appends it to the end of the existing data for the receiving array
            \item Inside the function: first transmits the length of data to be received then transfers the data
            \item No data is to be deleted at this time
            \item Allows for flexibility in implementation algorithm
        \end{itemize}
    \end{block}
    
    \begin{block}{cleanUp}
        \begin{itemize}
            \item To be used after all nodes have performed a swapArrayParts to all other nodes
            \item Will go back through each nodes array removing data that had been transferred by swapArrayParts and resizing the array for each node
        \end{itemize}
    \end{block}
\end{frame}

%%%%%%%%%%%%
%%% new section %%%
%%%%%%%%%%%%
\section{Testing}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Testing
		\end{center}
	\end{Huge}
\end{frame}

%\subsection{Results}

\begin{frame}	
	\frametitle{distributeFiles}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.30]{distributeFiles.png}
		\vspace{-10pt}
		\caption{Time to read directory and distribute files to workers}
	\end{figure}
	
\end{frame}

\begin{frame}	
	\frametitle{importFiles}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.30]{importFiles.png}
		\vspace{-10pt}
		\caption{Time to import 1000 rows from each file}
	\end{figure}
	
\end{frame}

\begin{frame}	
	\frametitle{initialSort}
	
	\begin{figure}[!htb]
		\centering
		\vspace{-5pt}
		\includegraphics[scale = 0.30]{initialSort.png}
		\vspace{-10pt}
		\caption{Time to sort 501000 rows}
	\end{figure}
	
\end{frame}


%%%%%%%%%%%%
%%
%% Conclusions
%%
%%%%%%%%%%%%

\section{Conclusions}

\begin{frame}	
	\begin{Huge}
		\begin{center}
			Conclusions
		\end{center}
	\end{Huge}
\end{frame}

\subsection{Challenges}

\begin{frame}	
	\frametitle{Challenges}
	
	\begin{block}{Integration}
		\begin{itemize}
			\item Identifying structure of parameters and return values
			\item Needed better planning of data types up front
		\end{itemize}
	\end{block}
	
	\begin{block}{Git}
		\begin{itemize}
			\item Resolving merge conflicts
			\item Basic Git workflow
		\end{itemize}
	\end{block}

	\begin{block}{Coding}
		\begin{itemize}
			\item Forgot to remove debug controls while collecting performance data
		\end{itemize}
	\end{block}

	\begin{block}{Testing}
		\begin{itemize}
			\item Long runtimes when testing with full dataset
			\item Failures during long runs
		\end{itemize}
	\end{block}

\end{frame}

\subsection{Future Work}

\begin{frame}	
	\frametitle{Future Work}
	
	\begin{block}{Reading the data}
		\begin{itemize}
			\item Read binary datainstead of ASCII for speedup
		\end{itemize}
	\end{block}
	
	\begin{block}{Data types}
		\begin{itemize}
			\item For simplicity, use vectors/structs instead of arrays
		\end{itemize}
	\end{block}
	
	\begin{block}{Finish data swap}
		\begin{itemize}
			\item Resolve scaling issues (overflowing buffer)
		\end{itemize}
	\end{block}
	
	\begin{block}{Testing}
		\begin{itemize}
			\item Easier collection of performance data
			\item Use loops in qsub files to automate multiple runs
		\end{itemize}
	\end{block}
	
\end{frame}

\end{comment}

 
\end{document}












